<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 3 | Sevens Chan blog | 陈日天技术博客</title>

  
  <meta name="author" content="SevensChan">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Sevens Chan blog"/>

  
  <meta property="og:image" content="/studyforinterview/favicon.ico"/>
  

  <link href="/studyforinterview/favicon.ico" rel="icon">
  <link rel="alternate" href="/studyforinterview/atom.xml" title="Sevens Chan blog" type="application/atom+xml">
  <link rel="stylesheet" href="/studyforinterview/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/studyforinterview/">Sevens Chan blog</a>
    </h1>
    <p class="site-description">陈日天技术博客</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/studyforinterview/">Home</a></li>
      
        <li><a href="/studyforinterview/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/08/16/how-javascript-timers-work/"><span>一起了解Javascript定时器</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/08/16/how-javascript-timers-work/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-15T16:00:00.000Z">
          2017-08-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<p><a href="/studyforinterview/tags/Javascript/">#Javascript</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章会聊聊关于Javascript的定时器以及它的执行机制，首先会先翻译一篇比较好的定时器和事件队列的文章，然后会根据一些经典的例题来更深入了解。</p>
<p>##<br>在基础层面上去了解 Javascript 定时器的工作原理是蛮重要的。因为单线程的问题很多时候他们的行为都是无意义的。让我们先来看看构建和操作Timers的函数。</p>
<ul>
<li><code>var id = setTimeout(fn,delay);</code> 初始化一个单次定时器，它会在设置的延迟时间(delay)后执行特定的回调函数。这个函数会返回一个唯一的ID，这个ID可以在之后用来取消这个定时器。</li>
<li><code>var id = setInterval(fn,delay);</code> 跟 <em>setTimeout</em> 类似，但是区别在于这个函数会多次执行直到它被停止。</li>
<li><code>clearInterval(id);clearTimeout(id);</code> 传入定时器的ID（ID由上面两个函数返回）然后停止定时器回调。</li>
</ul>
<p>为了了解定时器内部的运行原理，有一个很重要的概念我们需要探讨： 定时器延迟是不能保证的。因为所有的JS脚本都是在浏览器的单个线程上执行，异步事件在被触发的时候才会执行（例如鼠标事件和定时器），这个图可以很好的说清楚。</p>
<p><img src="https://johnresig.com/files/427px-Timers.png" alt="image_1"></p>
<p>这张图里面有很多知识点需要消化，但是完全理解了它就可以更好的帮助我们了解Javascript的异步事件机制的运作。这个图是一维的：垂直量度标记的是时间，单位是ms，蓝色框里面的是正在执行的Javascript部分。例如第一个Javascript部分执行了大概18ms，鼠标点击事件大概执行了11ms，以此类推。</p>
<p>因为Javascript只能一次执行一段代码（因为它的单线程性质），所有的代码块都会在线程里面堵塞其他的代码块。这意味着当异步事件发生的时候（例如鼠标点击事件，定时器触发或者一个XMLHttpRequest完成），它将会进入事件队列排队等待执行（这种排队实际上发生的情况肯定会因浏览器和浏览器之间的不同而有所不同，所以这里是一个简化的描述）。</p>
<p>首先，在第一个Javascript代码块中，两个定时器被启动：10ms的 setTimeout 和 10ms的 setInterval。定时器的启动时间和位置是在我们完成第一个代码块前就已经触发了。但是请注意，它不会立即执行（由于线程不能执行）。而是进入队列中以便再下一个可用时间执行。【译者补充：就是说会等第一代码块的顺序代码执行完后，回头才会去处理事件队列里面的代码。】</p>
<p>另外，在第一个Javascript代码块中我们还看到一个鼠标点击事件发生。与这个事件关联的异步回调函数也不会马上就执行（因为我们不会知道用户何时执行操作，因此这个时间也被认为是异步的），跟 timeout 事件初始化一样，它也会放入到队列里面稍后执行。</p>
<p>在初始化Javascript代码块执行完后浏览器马上会问一个问题：“还有谁？！谁在等着被执行？！” 在这个图的案例里面，鼠标点击回调事件和定时器的回调事件都在等着。浏览器会选择下一个队列事件（点击回调事件）并立即执行。timeout 的回调时间则会等待下一个时机去执行。</p>
<p>注意，当鼠标点击事件回调在执行的时候，第一个 interval 事件回调到达时间点执行，它会跟 timeout 的回调事件一样进入队列等待稍后执行。但是请注意，当 interval 再次被触发（当 timeout 的回调事件还在执行）的时候，这个 interval 的回调执行会被放弃。假如在执行大块代码块的时候对所有的 interval 回调进行排队，那么这一系列的回调之间将不会有延迟。但相反，浏览器事实上往往只是等待，在更多的其他的事件入队之前不会再有其他的 interval 回调事件(指相同ID interval衍生出来的回调事件) 会被放入队列。【译者补充：就是说，当一个占用时间较长的事件在执行的时候，如果队列中已经有一个相同ID interval产生的且还没执行的回调事件在，即使到达了再下一个得interval触发时间也不会有新的interval回调事件入队。】</p>
<p>事实上我们可以看到案例中第三个 interval 回调事件被触发的时候， 前一个 interval 回调事件正在执行。这告诉了我们一个事实：interval 回调事件不会在意什么当前执行的内容，它们会不加区分地进入队伍，即使回调事件之间的时间会被浪费掉。</p>
<p>最后在第二个 interval 回调事件执行完后，我们可以看到在javascipt引擎的队列里面已经没有东西可以执行了。这意味着浏览器现在会等待新的异步事件的发生。在 interval 回调事件再次触发的时候时间线已经到达50ms了，这一次，因为没有其他代码块在执行，所以这个 interval 回调事件会马上执行。</p>
<p>来看一个例子去更好地区分 <code>setTimeout</code> 和 <code>setInterval</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Some long block of code... */</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Some long block of code... */</span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>乍看之下，这两个代码片段似乎实现的功能是一致的，但仔细看其实不同。值得注意的是， 在前一个回调执行之后，setTimeout 的代码至少会有10ms的延迟才会执行（可能会更多，但不会更少）。 setInterval 则在每10ms的时间里都会尝试去执行回调，而不会管前一个回调执行的完成时间。</p>
<p>今天学习了很多，我们来回顾一下：</p>
<ul>
<li>Javascript 引擎只有一个单线程，强制异步事件排队等待执行。</li>
<li>setTimeout 和 setInterval 在它们如何处理异步代码之上有着根本性的不同</li>
<li>如果定时器被阻止立即执行，它将被延迟到下一个可能的执行点（这将会比期望的延迟时间更长）。</li>
<li>如果 Interval 的回调事件需要花费足够长的时间执行，那么它们将可以无延迟的背靠背(连续)执行。</li>
</ul>
<p>这些都是重要的基础知识。了解Javascript引擎的工作原理，特别是遇到大量异步事件的情况下，可以在构建高级应用程序代码的基础层面上做好准备。</p>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一题就是基础的不能再基础了顺序输出0 1 2 3 4<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"></span><br><span class="line">	&#125;, <span class="number">1000</span> * i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二题就有我们上一节提到的知识了，javascript会先把for循环执行完，把setTimeout的回调事件都放到事件队列中，等初始块代码执行完后再去处理事件队列里的回调事件，而这个时候，for局部里面的变量 i 已经一早递加为 5 了（注意，for循环是先执行语句3再去判断能不能执行内部语句的，所以 i 已经是 5 了）。因此结果是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"></span><br><span class="line">		&#125;, <span class="number">1000</span> * i);</span><br><span class="line"></span><br><span class="line">	&#125;)(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三题用了一个匿名函数和马上执行的传参来包住了setTimeout，就是说setTimeout 的 i 这个时候用的是闭包里面的局部变量 i，因为匿名函数的 i 传参不是引用传值而是数值传值，所以匿名函数里的 i 不会根据外面for循环的变量 i 的改变而改变。因此结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"></span><br><span class="line">		&#125;, <span class="number">1000</span> * i);</span><br><span class="line"></span><br><span class="line">	&#125;)(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四题考察的就是闭包的知识了，因为没有值传入，所以setTimeout读的还是已经跑完for循环的 i。因此结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">	setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"></span><br><span class="line">	&#125;)(i), <span class="number">1000</span> * i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五题setTimeout里面的回调函数被立即匿名调用了，所以先会跟正常输出一样，不会延迟执行。同时因为匿名函数没有返回值，所以 setTimeout 的回调函数是 undefined。输出结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//无延迟</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">	setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">returnfunction()&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;)(i), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据第五题的变形另外加一题，这题跟第五题的区别就是匿名函数有返回值，就是 setTimeout的回调函数就不再是undefined了，所以输出结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[0] 例题来源，小芋头君知乎live（如禁止发布请告知删除）</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/08/16/accuracy-of-javascript-time/"><span>Javascript时间的准确性</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/08/16/accuracy-of-javascript-time/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-15T16:00:00.000Z">
          2017-08-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<p><a href="/studyforinterview/tags/Javascript/">#Javascript</a></p>
<p>【本篇翻译原文发表时间是2008年，测试的浏览器可能也不是目前主流的浏览器，这篇仅供参考】</p>
<p>现在有两个问题我觉得需要好好考虑的。</p>
<p>第一，我看了一些 <a href="http://dromaeo.com/" target="_blank" rel="noopener">Dromaeo</a> 提供的测试用例之后，我发现从测试返回了一堆的 0ms。这是非常奇怪的，因为测试应该至少运行几毫秒，只得到一致的“0”结果是不可行的，特别是对于非平凡的代码。</p>
<p>第二，我运行过一些关于性能方面的测试，在IE浏览器上，在<a href="http://mootools.net/slickspeed/" target="_blank" rel="noopener">SlickSpeed</a> 选择套件测试上实验结果时间有着剧烈的波动。 当你想知道自己的修改时候有好处的时候，这是很难让每一个页面重新加载15-60毫秒的时间。</p>
<p>这两点让我做了一下调查。所有的Javascript 性能测试工具都用了下面这一段代码来测量他们的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = (newDate).getTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run a test. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> diff = (newDate).getTime() - start;</span><br></pre></td></tr></table></figure></p>
<p>确切的写法可能有所不同不过核心都是一样的，通过获得执行前的Date对象和执行后的Date对象之间的时间差来作为测试的总运行时间。</p>
<p>每次运行一段代码都会有很多地方有高有低的。这可能是因为在别的线程上有其他东西在执行，或者其他的进程占用了更多的进程。因此，实验的结果是波动的。测试波动的多少是一致的，沿着 <a href="http://en.wikipedia.org/wiki/Normal_distribution" target="_blank" rel="noopener">正态分布</a> 的某个部分：</p>
<p><img src="https://johnresig.com/files/standard.png" alt="image_1"></p>
<p>(很多测试套件在测试的时候例如 SunSpider 和 Dromaeo 都会使用 <a href="http://en.wikipedia.org/wiki/T-distribution" target="_blank" rel="noopener">T 分布</a> 来获得更好的分布图)<br>为了更好的了解结果，我写了一个<a href="https://johnresig.com/files/bugs/timer/" target="_blank" rel="noopener">小工具</a>用来运行下面的测试：运行一个空的函数，循环10,000次，查找和循环几千个divs，最后循环修改这些divs。我连续跑了这些测试并生成了下面的直方结果图。<br>这是在OS X系统上主要浏览器的结果：</p>
<p><img src="https://johnresig.com/files/gettime-osx.sm.png" alt="OS X"></p>
<p>这个结果是很棒的：在0ms附近有很多不同的结果（有一些结果到达了1-4ms，这是符合预期的），每个浏览器都会跟随正态分布的结果达到了7ms,13ms和22ms。这都是我们期待的结果，没什么惊喜。</p>
<p>【翻译到这里，发现这篇实在没有翻译的价值了，后面的东西都有点过时了。】<br>PEACE!</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/08/10/http-protocal/"><span>关于HTTP协议的一切</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/08/10/http-protocal/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-09T16:00:00.000Z">
          2017-08-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<h2 id="怎么理解协议"><a href="#怎么理解协议" class="headerlink" title="怎么理解协议"></a>怎么理解协议</h2><p>在总结HTTP协议之前，先来讲讲什么是协议。做过游戏行业的人应该对此理解比较深刻，因为游戏的通信协议没有太通用的规范，都是框架制定时候来约定的。按我理解，协议就是服务端和客户端通信时候所采用的规范和格式。</p>
<h2 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h2><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系 列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。<br>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算 机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p>
<p>关键词： 应用层协议，无状态协议<br>无状态协议的意思可以理解成请求之间是独立不影响的，因此服务端开发的时候需要引用session的概念来保持会话的持续性。</p>
<h2 id="HTTP协议的格式-Request"><a href="#HTTP协议的格式-Request" class="headerlink" title="HTTP协议的格式 - Request"></a>HTTP协议的格式 - Request</h2><p>HTTP Request由三个部分组成： 请求行，消息报头（Header），请求正文（body）</p>
<h2 id="HTTP-Request-请求行-请求方式-方式作用Get向Web服务器请求一个文件Post向Web服务器发送数据让Web服务器进行处理PUT向Web服务器发送数据并存储在Web服务器内部HEAD检查一个对象是否存在DELETE从Web服务器删除一个文件CONNECT对通道提供支持TRACE跟踪到服务器的路径OPTIONS查询Web服务器的性能"><a href="#HTTP-Request-请求行-请求方式-方式作用Get向Web服务器请求一个文件Post向Web服务器发送数据让Web服务器进行处理PUT向Web服务器发送数据并存储在Web服务器内部HEAD检查一个对象是否存在DELETE从Web服务器删除一个文件CONNECT对通道提供支持TRACE跟踪到服务器的路径OPTIONS查询Web服务器的性能" class="headerlink" title="HTTP Request 请求行 (请求方式)方式作用Get向Web服务器请求一个文件Post向Web服务器发送数据让Web服务器进行处理PUT向Web服务器发送数据并存储在Web服务器内部HEAD检查一个对象是否存在DELETE从Web服务器删除一个文件CONNECT对通道提供支持TRACE跟踪到服务器的路径OPTIONS查询Web服务器的性能"></a>HTTP Request 请求行 (请求方式)方式作用Get向Web服务器请求一个文件Post向Web服务器发送数据让Web服务器进行处理PUT向Web服务器发送数据并存储在Web服务器内部HEAD检查一个对象是否存在DELETE从Web服务器删除一个文件CONNECT对通道提供支持TRACE跟踪到服务器的路径OPTIONS查询Web服务器的性能</h2><h4 id="格式实例"><a href="#格式实例" class="headerlink" title="格式实例"></a>格式实例</h4><p>POST /test/test/index HTTP/1.1</p>
<ul>
<li>POST： HTTP的请求方式</li>
<li>/test/test/index: 请求Web服务器的目录地址</li>
<li>HTTP/1.1: URI（Uniform Resource Identifier，统一资源标识符）及其版本</li>
</ul>
<h4 id="问题引申：URL和URI区别"><a href="#问题引申：URL和URI区别" class="headerlink" title="问题引申：URL和URI区别"></a>问题引申：URL和URI区别</h4><p><strong>URI 是统一资源标识符，而 URL 是统一资源定位符</strong>。因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。例如 mailto、news 和 isbn URI 都是 URN 的示例。</p>
<p><strong>URI—Universal Resource Identifier通用资源标志符</strong></p>
<p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成</p>
<ul>
<li>访问资源的命名机制</li>
<li>存放资源的主机名</li>
<li>资源自身的名称，由路径表示，着重强调于资源。</li>
</ul>
<p><strong>URL—Uniform Resource Location统一资源定位符</strong></p>
<p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。<br>URL一般由三部组成</p>
<ul>
<li>协议(或称为服务方式)</li>
<li>存有该资源的主机IP地址(有时也包括端口号)</li>
<li>主机资源的具体地址。如目录和文件名等</li>
</ul>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>请求的Web服务器域名地址</p>
<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，Web服务器可以判断当前HTTP请求的客户端的浏览器类型。</p>
<p>例子：<br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11</p>
<h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>指定客户端能够接受的内容类型，内容类型中的先后次序表示客户端接收的先后次序。</p>
<p>例子：<br>Accept:text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,/;q=0.5<br>备注：<br>在Prototyp（1.5）的Ajax代码封装中，将Accept默认设置为“text/JavaScript, text/html, application/xml, text/xml, /”。这是因为Ajax默认获取服务器返回的Json数据模式。<br>在Ajax代码中，可以使用XMLHttpRequest 对象中setRequestHeader函数方法来动态设置这些Header信息。</p>
<blockquote>
<p>注意：很多参数后面都会有’q’参数，根据HTTP协议的<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="noopener">14.1章</a>，这个’q’参数可以理解喜好参数。例如上面q=0.9为最高，会优先选择text/plain类型,然后再到0.8最后0.5为空。</p>
</blockquote>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>指定HTTP客户端浏览器用来展示返回信息所优先选择的语言</p>
<p>例子：<br>Accept-Language: zh-cn,zh;q=0.5<br>这里默认为中文。</p>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。 </p>
<p>例子：<br>Accept-Encoding: gzip,deflate<br>备注：<br>其实在百度很多产品线中，apache在给客户端返回页面数据之前，将数据以gzip格式进行压缩。</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>浏览器可以接受的字符编码集</p>
<p>例子：<br>Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7</p>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>显示此HTTP请求提交的内容类型。一般<strong>只有post提交时</strong>才需要设置该属性。</p>
<p>例子：<br>Content-type: application/x-www-form-urlencoded;charset:UTF-8<br>有关Content-Type属性值可以如下两种编码类型：<br>1.“application/x-www-form-urlencoded”： 表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 然而，在向服务器发送大量的文本、包含非ASCII字符的文本或二进制数据时这种编码方式效率很低。<br>2.“multipart/form-data”： 在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。<br>当提交为单单数据时，可以使用“application/x-www-form-urlencoded”；当提交的是文件时，就需要使用“multipart/form-data”编码类型。<br>在Content-Type属性当中还是指定提交内容的charset字符编码。一般不进行设置，它只是告诉web服务器post提交的数据采用的何种字符编码。<br>一般在开发过程，是由前端工程与后端UI工程师商量好使用什么字符编码格式来post提交的，然后后端ui工程师按照固定的字符编码来解析提交的数据。所以这里设置的charset没有多大作用。</p>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>表示是否需要持久链接，如果Web服务器接收到值为”Keep-Alive”，或者看到请求使用的是HTTP 1.1(<strong>HTTP 1.1默认进行持久连接</strong>)，它就可以利用持久连接的优点，当页面包含多个元素时（例如Appley，图片），显著地减少下载所需要的时间。要实现这一点，Web服务器需要在返回客户端HTTP头信息中发送一个Content-Length头参数（返回信息正文的长度），最简单的实现方法就是：先把内容写入ByteArrayOutputStream，然 后在正式写出内容之前计算它的大小。 </p>
<p>例子：<br>Connection: keep-alive</p>
<h4 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h4><p>显示此HTTP连接的Keep-Alive时间，使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接。<br>以前HTTP请求是一站式连接，从HTTP/1.1协议之后，就有了长连接，即在规定的Keep-Alive时间内，连接是不会断开的。 </p>
<p>例子：<br>Keep-Alive: 300</p>
<blockquote>
<p>可以保持长连接那么HTTP协议还是无状态的吗？答案是肯定的，因为保持长连接是保持TCP的连接，协议本身依然不会保存事务处理的信息。</p>
</blockquote>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>客户端是否支持cache。no-cache表示客户端不支持cache，如max-age=3600，告诉User Agent 该请求的响应结果在多长时间内有效，在有效期内，当用户再次需要访问时，直接从客户端本地提取，不需要访问服务器。</p>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>消息产生的当前时间</p>
<p>例子：<br>Mon, 21 Aug 2017 07:50:24 GMT</p>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p>如果请求消息包含If-Modified-Since标题域，GET方法的语法就变成“条件GET”，即“（conditional GET）”。 条件GET方法可以对指定资源进行判断，如果它在If-Modified-Since标题域中的指定日期后发生了更新，才启动传输，否则不传输。这种条件GET允许被缓存的实体在不必经过多次请求或不必要的数据传输就能进行刷新，从而有助于降低网络负载。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>上次修改的时间</p>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>一般应用在文件下载上，用于标识响应内容的最后修改时间或内容较验码，当下一次User agent需要时，服务首先判断这二个值是否跟服务器上一致，一样则不需要返回内容。</p>
<p>例子：<br>“1cbf3-dfd-3a2adcd8”</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>该请求的响应结果在什么时间失效，在没有失效之前，代理可直接从缓存中返回以前的响应结果。</p>
<h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>包括实现特定的指令，它可应用到响应链上的任何接收方</p>
<p>例子：<br>Pragma: no-cache</p>
<h2 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h2><p>Response组成部分也有三部分：状态行，Header,Body</p>
<p>### </p>
<h3 id="HTTP-Response-Header"><a href="#HTTP-Response-Header" class="headerlink" title="HTTP Response Header"></a>HTTP Response Header</h3><p>Response的Header参数跟Request很多类似，重复的在此省略</p>
<h4 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h4><p>状态码</p>
<h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><p>服务端设置客户端cookie。设置格式是name=value，设置多个参数时中间分号隔开。Set-Cookie时还会用到几个参数：PATH设置有效路径，DOMAIN设置cookie生效的域名，Expire设置cookie的有效时间，0表示关闭浏览器就失效。</p>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>当服务器返回3xx重定向时，该参数实现重定向。广告链接的跳转就使用这种协议。</p>
<h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p>附属体（数据实体）的长度</p>
<h2 id="常见例题"><a href="#常见例题" class="headerlink" title="常见例题"></a>常见例题</h2><p>1.下面HTTP头中<strong>_</strong>不是和浏览器缓存相关<br>A. Expires<br>B. Cache-Control<br>C. ETag<br>D. Date</p>
<p>解析：Expires表示缓存过期的时间，Cache-Control表示缓存的规则(不保留或者或留多久)，ETag和Last-Modified配合使用查看是否读取缓存，Date是发送request的当前时间。所以答案选<strong>D</strong>。</p>
<h2 id="郭无心"><a href="#郭无心" class="headerlink" title=",郭无心"></a>,郭无心</h2><p>[4]《技术之瞳》,阿里巴巴集团校园招聘笔试项目组</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/08/08/jquery-plugin-develop/"><span>全家一起来开发一个Jquery插件</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/08/08/jquery-plugin-develop/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-07T16:00:00.000Z">
          2017-08-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<h2 id="小梦想"><a href="#小梦想" class="headerlink" title="小梦想"></a>小梦想</h2><p>我相信每个用过Jquery的人都有一个小梦想，就是写一个自己的Jquery插件——然后放上github，收获nk+星星，登上人生巅峰迎娶白富美。。我也不例外，在爱上vue.js以后回头来写Jquery有很多感觉都不一样了，JS的面向对象感觉理解更深了。</p>
<p>P.S:虽然Jquery已经不再是很多人的首选了，但作为曾经的绝对霸主级JS库，还是很多地方值得我们学习参考的。</p>
<h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>要放上github的话肯定又有“高颜值”啦，指的是整个项目的架构要规范。这里就直接使用grunt的脚手架来搭建项目：</p>
<p>当然，grunt的模板是需要自己下的。具体命令是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">git clone https://github.com/gruntjs/grunt-init-jquery.git ~/.grunt-init/jquery</span><br></pre></td></tr></table></figure>
<p>模板下好以后就可以去到我们的插件目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">grunt-int jquery</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>装好依赖包之后，看看我们的项目架构，好爽。。连README都有了。</p>
<h2 id="插件结构"><a href="#插件结构" class="headerlink" title="插件结构"></a>插件结构</h2><p>grunt模板里面给的插件结构也很漂亮，不过我还是个人的结构。</p>
<p>首先用闭包包着我们的插件，目的是防止$符号污染，因为$是很多库的宠儿，这里使用闭包确保我们闭包内的$是jquery对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">;(function($,window,document)&#123;</span><br><span class="line"></span><br><span class="line">	//插件内容</span><br><span class="line"></span><br><span class="line">&#125;(jQuery,window,document));</span><br></pre></td></tr></table></figure></p>
<p>然后放入jquery扩展函数定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">;(function($,window,document)&#123;</span><br><span class="line"></span><br><span class="line">	//插件内容</span><br><span class="line"></span><br><span class="line">	$.fn.extend(&#123;</span><br><span class="line"></span><br><span class="line">		tagSelect: function (option)&#123;</span><br><span class="line"></span><br><span class="line">			var plugin = new TagSelect(this, option);</span><br><span class="line"></span><br><span class="line">			return plugin.init();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	//TagSelect 类</span><br><span class="line"></span><br><span class="line">	var TagSelect = function (ele, opt)&#123;</span><br><span class="line"></span><br><span class="line">		//私有变量</span><br><span class="line"></span><br><span class="line">		this.$element = ele;</span><br><span class="line"></span><br><span class="line">		this.defaultSetting = &#123; </span><br><span class="line"></span><br><span class="line">			maxNum: 5,</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		this.setting = $.extend(&#123;&#125;,this.defaultSetting, opt);</span><br><span class="line"></span><br><span class="line">		//私有函数</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//公有函数</span><br><span class="line"></span><br><span class="line">	TagSelect.prototype = &#123;</span><br><span class="line"></span><br><span class="line">		init: function()&#123;	</span><br><span class="line"></span><br><span class="line">			return this.$element;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;(jQuery,window,document));</span><br></pre></td></tr></table></figure></p>
<p>tagSelect 是我们的插件名称，插件的定义和实现可以直接写在这个函数中，不过为了开发规范，我把这部分抽象出来。</p>
<p>再下面就是TagSelect类，插件的实际内容都在这里了，留意这一部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">this.defaultSetting = &#123; </span><br><span class="line"></span><br><span class="line">			maxNum: 5,</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">this.setting = $.extend(&#123;&#125;,this.defaultSetting, opt);</span><br></pre></td></tr></table></figure></p>
<p>defaultSetting就是我们插件默认设置的设定，通过 $.extend() 函数把defaultSetting和opt合并在一起，重复部分使用后者的内容。</p>
<p>这个就是我们插件的整体结构了。</p>
<h2 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h2><p>因为直接用的是 $.fn.extend jquery的插件扩展机制，所以使用也是一句话的事情啦~~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">$(&apos;#target&apos;).tagSelect(&#123;</span><br><span class="line"></span><br><span class="line">	maxNum : 10</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>参数传的是设置，这样调用就把我们的maxNum设成了10了。</p>
<p>写到这里啦，有缺失部分再补充~</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/08/07/trans-rate/"><span>传输速率计算问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/08/07/trans-rate/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-06T16:00:00.000Z">
          2017-08-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<h2 id="由一道题开始说起"><a href="#由一道题开始说起" class="headerlink" title="由一道题开始说起"></a>由一道题开始说起</h2><p><strong>使用一辆卡车运输n块装满数据的1TB硬盘，以80km/h行驶1000km将数据运送到目的地，卡车至少运送<em>__</em>块硬盘才能使速率超过1000G bit/s?</strong></p>
<p>解：<br>这就是关于传输速率和传输介质的问题，例题来源于阿里的《技术之瞳》。<br>要解决这样的题，我们首先要清晰其中的单位关系。</p>
<p>首先计算总时间：t = s %uF7 v = 1000 km %uF7 80 km / h = 12 .5 h<br>然后计算总时间内可以传输的数据量：<br>s2 GB = v2 %uD7 t = 1000 G b/s %uF7 8b/B %uD7 12.5 h %uD7 3600 s/h<br>         =  5625000 GB<br>(其中s2为总数据量，v2为传输速率)<br>(注意单位要一致，12.5小时要转为秒，1000G b/s 是bit每秒，而最后数据量的单位是byte，因为1 byte = 8 bit，所以要除上 8b/B)<br>最后用总的数据量除以每块硬盘的size就可以知道至少运送多少块了：<br>n = s2 GB %uF7 1024 GB/块 = 562500 GB %uF7 1024 GB/块 = 5494 块</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>这类题目公式其实就是s=vt，主要要留意单位要一致。</p>
<h2 id="再来一题"><a href="#再来一题" class="headerlink" title="再来一题"></a>再来一题</h2><p><strong>有以下数据传输方法，请按照速率排序：</strong><br><strong>1.从一台计算机的A硬盘复制数据到B硬盘</strong><br><strong>2.通过10Gbit/s的局域网访问一台机器的内存</strong><br><strong>3.通过10Mbit/s的ADSL下载互联网资源</strong><br><strong>4.通过快递邮寄1TB硬盘，24小时内送达</strong></p>
<p>解：<br>首先我们可以确认的是四个答案的速率差距应该都是清晰。<br>1.硬盘的速度大概是60 MB/s<br>2.10G bit/s =&gt; 10 %uF7 8 b/s = 1.25GB/s = 1280 MB/s<br>3.10M bit/s =&gt; 10 %uF7 8 b/s = 1.25B /s ≈ 0.00125MB/s<br>4.1TB %uF7 24h =&gt; 1024 GB %uF7 8 b/s %uF7 24 %uD7 3600 s/h =&gt; 19200 B/s ≈ 19.2 MB/s<br>所以 2&gt;1&gt;4&gt;3</p>
<h2 id="大总结"><a href="#大总结" class="headerlink" title="大总结"></a>大总结</h2><p>就这样子了</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/07/31/log-system-build/"><span>项目日志系统设计和搭建</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/07/31/log-system-build/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-30T16:00:00.000Z">
          2017-07-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="/studyfortencent/tags/日志/">#日志</a></p>
<h2 id="缺少的Log"><a href="#缺少的Log" class="headerlink" title="缺少的Log"></a>缺少的Log</h2><p>个人负责的商城平台遇到一件事件，具体内容不方便公开，不过从中发现了一个比较重要的问题，就是系统中可以查找的log太少了。我们的平台基于的是shopnc商城，有些重要的位置没有记录用户的操作日志和用户IP信息之类，造成责任归属困难。所以上级要求我在重要的地方加添更多的Log点。</p>
<h2 id="当前系统"><a href="#当前系统" class="headerlink" title="当前系统"></a>当前系统</h2><p>当前系统用得较多的log就是member表里面记录的两次用户登录IP</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/07/28/nginx-accesslog/"><span>最熟悉的陌生人 - access log</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/07/28/nginx-accesslog/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-27T16:00:00.000Z">
          2017-07-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> access log一直是我们服务端运维找问题的好帮手，但是作为一个偏应用层的开发者来说，可能会有着那么一点陌生，例如access log写入日志的时机是什么时候呢？谁能写？怎么配置等等，所以在这篇文章里面，我会试图从官方文档去找到所需要的一切的答案。</p>
<h2 id="什么是access-log"><a href="#什么是access-log" class="headerlink" title="什么是access log"></a>什么是access log</h2><p>顾名思义，access log就是用来记录用户的请求日志。可通过nginx的配置文件来配置他的保存位置和输出的日志格式。</p>
<h2 id="日志告诉了我们什么信息"><a href="#日志告诉了我们什么信息" class="headerlink" title="日志告诉了我们什么信息"></a>日志告诉了我们什么信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">176.51.166.239 - - [28/Jul/2017:15:41:30 +0800] &quot;POST /wp-login.php HTTP/1.1&quot; 200 2644 &quot;http://awesomesevens.com/wp-login.php&quot; &quot;Mozilla/5.0 (Windows NT 6.0; rv:34.0) Gecko/20100101 Firefox/34.0&quot;</span><br></pre></td></tr></table></figure>
<p>这是一条默认的日志，具体的内容我们参照官网给的默认格式来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">log_format main &apos;$remote_addr - $remote_user [$time_local] &apos;</span><br><span class="line"></span><br><span class="line">                           &apos;&quot;$request&quot; $status $body_bytes_sent &apos;</span><br><span class="line"></span><br><span class="line">                           &apos;&quot;$http_referer&quot; &quot;$http_user_agent&quot;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>176.51.166.239<br>$remote_addr : 客户端(用户)的请求IP</p>
</li>
<li><p>-<br>$remote_user : 已经经过Auth Basic Module验证的用户名。”-“就是没有记录到。</p>
</li>
<li><p>[28/Jul/2017:15:41:30 +0800]<br>$time_local  : 记录的时间</p>
</li>
<li><p>“POST /wp-login.php HTTP/1.1”<br>$request : 请求的url，POST 为请求的方法，HTTP/1.1为请求的协议</p>
</li>
<li><p>200<br>$status : 请求的状态，具体的状态代表的意义可以看我的另一篇文章 <a href="https://superhos.github.io/studyforinterview/2017/07/28/dev-code/">开发时候常会遇到的状态码</a></p>
</li>
<li><p>2644<br>$body_bytes_sent : 传送页面的字节数</p>
</li>
<li><p><a href="http://awesomesevens.com/wp-login.php" target="_blank" rel="noopener">http://awesomesevens.com/wp-login.php</a><br>$http_referer : 来源页面，即从哪个页面转到本页</p>
</li>
<li><p>Mozilla/5.0 (Windows NT 6.0; rv:34.0) Gecko/20100101 Firefox/34.0<br>$http_user_agent : 用户的浏览器信息，终端，版本等</p>
</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置也很简单，在nginx config的server配置中加入下面一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">access_log  /var/log/nginx/access.log  main;</span><br></pre></td></tr></table></figure></p>
<p>中间是要放置的log的地址，后面的main对应的是上一节设定的格式。</p>
<h2 id="access太大怎么办"><a href="#access太大怎么办" class="headerlink" title="access太大怎么办"></a>access太大怎么办</h2><p>我的建议是如果访问量大得夸张的话，最好把日志一块交给应用层去做，抽出来做一个日志系统，方便后续的分析。<br>如果访问量还没到夸张的层次的时候，也要考虑日志的占用空间问题。所以对每天的日志进行压缩和转存就很有必要了。网上的有人用的是写shell+crontab来做，但其实linux本来已经提供了一个很好的工具给我们去做这件事情，叫logrotate。<br>一般logrotate的配置文件会放置在 <em>/etc/logrotate.d</em> 路径下，下面是我的一个logrotate对于nginx日志的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/var/log/nginx/*.log &#123;</span><br><span class="line"></span><br><span class="line">        daily</span><br><span class="line"></span><br><span class="line">        missingok</span><br><span class="line"></span><br><span class="line">        rotate 14</span><br><span class="line"></span><br><span class="line">        compress</span><br><span class="line"></span><br><span class="line">        delaycompress</span><br><span class="line"></span><br><span class="line">        notifempty</span><br><span class="line"></span><br><span class="line">        create 0640 www-data adm</span><br><span class="line"></span><br><span class="line">        sharedscripts</span><br><span class="line"></span><br><span class="line">        prerotate</span><br><span class="line"></span><br><span class="line">                if [ -d /etc/logrotate.d/httpd-prerotate ]; then \</span><br><span class="line"></span><br><span class="line">                        run-parts /etc/logrotate.d/httpd-prerotate; \</span><br><span class="line"></span><br><span class="line">                fi \</span><br><span class="line"></span><br><span class="line">        endscript</span><br><span class="line"></span><br><span class="line">        postrotate</span><br><span class="line"></span><br><span class="line">                invoke-rc.d nginx rotate &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">        endscript</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数 功能<br>compress 通过gzip 压缩转储以后的日志<br>nocompress 不需要压缩时，用这个参数<br>copytruncate 用于还在打开中的日志文件，把当前日志备份并截断<br>nocopytruncate 备份日志文件但是不截断<br>create mode owner group 转储文件，使用指定的文件模式创建新的日志文件<br>nocreate 不建立新的日志文件<br>delaycompress 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩<br>nodelaycompress 覆盖 delaycompress 选项，转储同时压缩。<br>errors address 专储时的错误信息发送到指定的Email 地址<br>ifempty 即使是空文件也转储，这个是 logrotate 的缺省选项。<br>notifempty 如果是空文件的话，不转储<br>mail address 把转储的日志文件发送到指定的E-mail 地址<br>nomail 转储时不发送日志文件<br>olddir directory 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统<br>noolddir 转储后的日志文件和当前日志文件放在同一个目录下<br>prerotate/endscript 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行<br>postrotate/endscript 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行<br>daily 指定转储周期为每天<br>weekly 指定转储周期为每周<br>monthly 指定转储周期为每月<br>rotate count 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份<br>tabootext [+] list 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~<br>size size 当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem).</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/07/28/git-branch-strategy/"><span>关于git项目管理分支策略的一点思考</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/07/28/git-branch-strategy/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-27T16:00:00.000Z">
          2017-07-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<h2 id="00"><a href="#00" class="headerlink" title="00"></a>00</h2><p>作为组员的时候，对git的理解没太深，只知道fetch，rebase之类的简单运用，没有上升到项目管理的层面。到要自己去负责的时候，应了那句老话，人生处处是学问。</p>
<p>然后开始在网上看看前人的经验，可参考的文章大都在谈2010年Vincent Driessen的文章。毕竟经验不多，在这里只能留一下自己当前的想法，以后随时更新。</p>
<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>我们项目的当前git分支策略是采用一人一条分支的策略，是由之前的同事制定的。示意图如下：</p>
<p><img src="https://static.oschina.net/uploads/space/2017/0712/145304_AFtO_203607.jpg" alt="当前分支策略示意图"><br>Figure 1. 当前分支策略示意图</p>
<p>这种策略的优点：</p>
<ol>
<li>责任明确。master中的代码都可以较简单的追踪到分支上。</li>
<li>分支清晰。在人员少的时候，可以保持分支明朗。</li>
</ol>
<p>但是作为组员，我认为这种分支策略是缺点远远大于优点的，主要缺點如下：</p>
<ol>
<li><p>不适应高频需求团队。因为需求不断砸来，缺少里程碑版本的确定，导致每个新需求来都需要马上上线，导致组员缺少同步远程库和本地库代码的时机，我有位同事开发了三个月竟然都没同步过线上的代码，可想而知一旦更新代码冲突会多严重。</p>
</li>
<li><p>需求必须线性合并到master上。因为每个组员只有一条自己的分支，必然会有需求先后次序的冲突，例如：开发的时候a，b，c三个需求依次开发，却被要求先要上线c需求，那么c需求就可能有代码耦合在a，b需求中，导致功能缺失。</p>
</li>
</ol>
<p>因此，我开始寻找另外更好的分支策略</p>
<h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>然后参考了A successful Git branching model [0] 的模型，开始搭建自己的branch模型。</p>
<p>主要就是master，development branch 和 issue-<em> branch。 先说issue-</em> branch，我另外搭建了一個issue系统（bug追踪系统），所有的需求开发，bug修改都需要在系统中先report。之后开发人员就可以根据issue系统給的issue id去创建分支，由于和issue系统的结合，就可以把一个大的需求切分不同部分给不同的开发人员去做。之后要合并上线的话只需要根据issue id号合并就行，最后删掉分支。</p>
<p>由于时间关系准备开会，第二部分先简略说下，之後再補充</p>
<p>Refference</p>
<p>[0] Vincent Driessen,A successful Git branching model . <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">http://nvie.com/posts/a-successful-git-branching-model/</a></p>
<p>[1] 阮一峰, <a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/07/git.html</a>. <a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/07/git.html</a></p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/07/28/dev-code/"><span>开发时候常会遇到的HTTP状态码</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/07/28/dev-code/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-27T16:00:00.000Z">
          2017-07-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<p>关于HTTP协议，可以看我的而另一篇文章：<a href="https://superhos.github.io/studyforinterview/2017/08/10/http-protocal/">关于HTTP协议的一切</a></p>
<p>这篇查询用[0]</p>
<p>HTTP:Status 1xx (临时响应) 表示说临时响应并需要请求者继续执行操作<br>HTTP:Status 2xx (成功) 表示成功处理了请求<br>HTTP:Status 3xx (重定向) 表示要完成请求需要进一步操作。通常这些状态码用来重定向 。<br>HTTP:Status 4xx (错误) 表示请求可能出错，妨碍了服务器的处理<br>HTTP:Status 5xx (服务器错误) 表示服务器在尝试处理请求时发生了内部错误。这些错误可能是服务器本身引起的，而不是请求错误。</p>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p>200 (成功)<br>304 (未修改) 自上次请求后，请求的网页未修改过。服务器返回此响应时，不返回网页请求，客户端可以一般读取缓存。<br>401 (未授权) 请求要求身份验证。<br>403 (禁止) 服务器拒绝请求。<br>404 (未找到) 服务器找不到请求的网页<br>500 (服务器出错) 要看log找错了<br>504 (服务响应超时)</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[0]《技术之瞳》，阿里巴巴集团校园招聘笔试项目组</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/studyforinterview/2017/07/25/参考书籍/"><span>参考书籍</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/studyforinterview/2017/07/25/参考书籍/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-24T16:00:00.000Z">
          2017-07-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="https://superhos.github.io/studyforinterview/2017/07/25/起航/"><br>                        返回目录
                </a></p>
<p><a href="/studyforinterview/tags/参考/">#参考</a></p>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>[1]《技术之瞳》，阿里巴巴集团校园招聘笔试项目组<br>[2]《Vue.js权威指南》，张耀春，黄轶，王静，苏伟等著<br>[3]《你不知道的JavaScript 上卷/中卷》，[美] Kyle Simpson</p>
<hr>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言:"></a>留言:</h3><p>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/studyforinterview/page/2/" class="pagination-prev">Prev</a>
  
  
  <a href="/studyforinterview/page/4/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 SevensChan
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>